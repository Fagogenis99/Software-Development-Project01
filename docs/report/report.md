# Αναφορά Αποτελεσμάτων και Συγκριτική Ανάλυση Αλγορίθμων

## Εισαγωγή

Στην παρούσα εργασία υλοποιήθηκαν και συγκρίθηκαν οι αλγόριθμοι αναζήτησης προσεγγιστικών κοντινότερων γειτόνων (Approximate Nearest Neighbors) πάνω σε πολυδιάστατα δεδομένα:

- **LSH (Locality-Sensitive Hashing)**
- **Hypercube**
- **IVFFlat (Inverted File Flat)**
- **IVFPQ (Inverted File with Product Quantization)**

Οι αλγόριθμοι δοκιμάστηκαν σε δεδομένα τύπου **MNIST**, με στόχο τη μείωση του χρόνου αναζήτησης σε σχέση με την ακριβή ευκλείδεια αναζήτηση (brute-force), διατηρώντας ικανοποιητική ακρίβεια (Recall).

---

## Θεωρητική Ανάλυση Πολυπλοκότητας και Αναμενόμενης Συμπεριφοράς

### LSH (Locality-Sensitive Hashing)

Ο LSH βασίζεται στη χρήση τυχαίων προβολών, ώστε διανύσματα με μικρή απόσταση να καταλήγουν με μεγαλύτερη πιθανότητα στο ίδιο bucket ενός hash table.

**Πολυπλοκότητα:**
- Χρόνος εκπαίδευσης: `O(n·k·L)`
- Χρόνος αναζήτησης: `O(L·k + C)` (C: αριθμός υποψηφίων)
- Μνήμη: `O(n·L)`

Πολύ μικρός χρόνος αναζήτησης, αλλά η ακρίβεια (Recall) εξαρτάται από τις παραμέτρους L, k, w.

 **Αποτελέσματα:**  
Recall ≈ **1.0**, tApprox ≈ **50–60 ms**, QPS ≈ **17–19**  
 Πολύ σταθερή ακρίβεια και γρήγορη απόδοση.

---

### IVFFlat (Inverted File Flat)

Ο IVFFlat χωρίζει τον χώρο σε *kclusters* με k-means. Κάθε query εξετάζει μόνο *nprobe* clusters.

**Πολυπλοκότητα:**
- Εκπαίδευση: `O(n·k·d)`
- Αναζήτηση: `O(nprobe·(n/k)·d)`
- Μνήμη: `O(n·d)`

 **Αποτελέσματα:**  
Recall = **1.0** για όλα τα πειράματα, με tApprox από **2 έως 25 ms**.  
Ο χρόνος αυξάνεται με το *nprobe*, αλλά η ακρίβεια παραμένει τέλεια.

---

### IVFPQ (Inverted File with Product Quantization)

Ο IVFPQ επεκτείνει τον IVFFlat μειώνοντας τη μνήμη με *M υποχώρους* και *nbits bits* ανά υποκώδικα.

**Πολυπλοκότητα:**
- Εκπαίδευση: `O(n·k·d + n·M·2^{nbits})`
- Αναζήτηση: `O(nprobe·M)`
- Μνήμη: `O(n·M)`

 **Αποτελέσματα:**  
Recall ≈ **0.2–0.6**, AF ≈ **1.3–1.5**  
tApprox ≈ **0.1–1.5 ms**, QPS **500–7000+**  
Εξαιρετικά γρήγορος με μικρή απώλεια Recall.

---

### Hypercube

Ο Hypercube μετατρέπει κάθε σημείο σε bit-vector και οργανώνει τον χώρο σαν δυαδικό κυβικό γράφο.

 **Αποτελέσματα:**  
Recall ≈ **0–0.2**, AF ≈ **1.7–2.4**  
tApprox ≈ **0.05–0.17 ms**, QPS **10.000–20.000**  
 Εξαιρετικά γρήγορος αλλά χαμηλή ακρίβεια.

---

## Συγκριτική Αξιολόγηση

| Αλγόριθμος | Χρόνος Αναζήτησης | Μνήμη | Recall | QPS | Παρατήρηση |
|-------------|------------------|--------|---------|------|-------------|
| **LSH** | ~50–60 ms | Υψηλή | 1.0 | ~18 | Πολύ σταθερή ακρίβεια |
| **Hypercube** | <0.2 ms | Χαμηλή | 0–0.2 | 10k–20k | Εξαιρετικά γρήγορος |
| **IVFFlat** | 2–25 ms | Υψηλή | 1.0 | 100–400 | Άριστη ισορροπία |
| **IVFPQ** | 0.1–1.5 ms | Πολύ χαμηλή | 0.2–0.6 | 500–7000 | Ταχύτερος συνολικά |

---

## Συμπεράσματα

- Ο **LSH** αποδείχθηκε ο πιο **σταθερός** με υψηλή ακρίβεια αλλά μεγαλύτερο χρόνο.  
- Ο **Hypercube** έχει εξαιρετική ταχύτητα αλλά χαμηλό Recall.  
- Ο **IVFFlat** προσφέρει **σχεδόν τέλεια ακρίβεια** με **μέτριο χρόνο**.  
- Ο **IVFPQ** είναι **ο πιο αποδοτικός συνολικά**, προσφέροντας πολύ υψηλό QPS και χαμηλή μνήμη.  

 **Συνεπώς:**
- Για *real-time* αναζητήσεις → **LSH**
- Για *υψηλή ακρίβεια* → **IVFFlat**
- Για *πολύ μεγάλα datasets* → **IVFPQ**
